<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Tank Mission</title>
<style>
  html,body{margin:0;height:100%;background:#05070f;overflow:hidden;}
  canvas{display:block;width:100vw;height:100vh;touch-action:none;}
</style>
</head>
<body>
<canvas id="c"></canvas>

<script>
/* ====== CONFIG from URL ====== */
const qs = new URLSearchParams(location.search);

const cfg = {
  tankUrl: qs.get("tankUrl") || "https://img.genially.com/66f849d0f7b39c0016fdd814/59b10492-4c07-41bd-9331-69042a9d74b9.png",
  boxUrl:  qs.get("boxUrl")  || "https://img.genially.com/66f849d0f7b39c0016fdd814/9bfc40ad-c0ef-4bb9-a006-30014520bb33.png",
  bgUrl:   qs.get("bgUrl")   || "",

  boxCount: Math.min(15, Math.max(1, Number(qs.get("boxCount") || 7))),
  speed:    Math.max(1, Number(qs.get("speed") || 4)),

  tankScale: Math.max(0.5, Math.min(5, Number(qs.get("tankScale") || 1))),
  boxScale:  Math.max(0.5, Math.min(5, Number(qs.get("boxScale") || 1)))
};

/* ====== CANVAS ====== */
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");

function resize(){
  const dpr = Math.max(1, window.devicePixelRatio || 1);
  canvas.width  = Math.floor(innerWidth * dpr);
  canvas.height = Math.floor(innerHeight * dpr);
  canvas.style.width = innerWidth + "px";
  canvas.style.height = innerHeight + "px";
  ctx.setTransform(dpr,0,0,dpr,0,0);
}
addEventListener("resize", resize);
resize();

/* ====== IMAGES ====== */
function loadImg(url){
  const img = new Image();
  img.crossOrigin = "anonymous";
  img._ok = false;
  img.onload = ()=> img._ok = true;
  img.onerror = ()=> img._ok = false;
  img.src = url;
  return img;
}
let tankImg = loadImg(cfg.tankUrl);
let boxImg  = loadImg(cfg.boxUrl);
let bgImg   = cfg.bgUrl ? loadImg(cfg.bgUrl) : null;

/* ====== GAME STATE ====== */
const tankBase = { w: 120, h: 80 };
const boxBase  = { s: 80 };

const tank = {
  x: 40,
  y: 0,          // выставим после resize()
  dir: "right",
  w: tankBase.w * cfg.tankScale,
  h: tankBase.h * cfg.tankScale,
};

function placeTankStart(){
  tank.w = tankBase.w * cfg.tankScale;
  tank.h = tankBase.h * cfg.tankScale;
  tank.x = 40;
  tank.y = innerHeight - tank.h - 40; // нижний левый, но не у края
}
placeTankStart();
addEventListener("resize", placeTankStart);

const keys = Object.create(null);
addEventListener("keydown", e => { keys[e.key] = true; });
addEventListener("keyup",   e => { keys[e.key] = false; });

const boxes = [];
function spawnBoxes(){
  boxes.length = 0;
  const size = boxBase.s * cfg.boxScale;

  for(let i=0;i<cfg.boxCount;i++){
    // гарантируем, что ящики не “уходят” за край:
    const x = Math.random() * Math.max(1, (innerWidth  - size));
    const y = Math.random() * Math.max(1, (innerHeight - size));
    boxes.push({ x, y, s: size });
  }
}
spawnBoxes();

/* ====== DRAW HELPERS ====== */
function drawDefaultField(){
  // красивый фон по умолчанию (вместо черноты)
  const g = ctx.createRadialGradient(innerWidth*0.5, innerHeight*0.45, 50, innerWidth*0.5, innerHeight*0.5, Math.max(innerWidth, innerHeight));
  g.addColorStop(0, "rgba(20,35,70,1)");
  g.addColorStop(1, "rgba(5,8,16,1)");
  ctx.fillStyle = g;
  ctx.fillRect(0,0,innerWidth,innerHeight);
}

function drawPlaceholderBox(b){
  ctx.save();
  ctx.globalAlpha = 0.85;
  ctx.fillStyle = "rgba(200,200,200,0.25)";
  ctx.strokeStyle = "rgba(255,255,255,0.35)";
  ctx.lineWidth = 2;
  ctx.fillRect(b.x, b.y, b.s, b.s);
  ctx.strokeRect(b.x, b.y, b.s, b.s);
  ctx.restore();
}

function drawPlaceholderTank(){
  ctx.save();
  ctx.globalAlpha = 0.9;
  ctx.fillStyle = "rgba(255,215,0,0.25)";
  ctx.strokeStyle = "rgba(255,215,0,0.5)";
  ctx.lineWidth = 2;
  ctx.fillRect(tank.x, tank.y, tank.w, tank.h);
  ctx.strokeRect(tank.x, tank.y, tank.w, tank.h);
  ctx.restore();
}

/* ====== UPDATE ====== */
function update(){
  let dx = 0, dy = 0;

  const left  = keys["ArrowLeft"]  || keys["a"] || keys["A"];
  const right = keys["ArrowRight"] || keys["d"] || keys["D"];
  const up    = keys["ArrowUp"]    || keys["w"] || keys["W"];
  const down  = keys["ArrowDown"]  || keys["s"] || keys["S"];

  if (left)  { dx = -cfg.speed; tank.dir = "left"; }
  if (right) { dx =  cfg.speed; tank.dir = "right"; }
  if (up)    { dy = -cfg.speed; tank.dir = "up"; }
  if (down)  { dy =  cfg.speed; tank.dir = "down"; }

  tank.x = Math.max(0, Math.min(innerWidth  - tank.w, tank.x + dx));
  tank.y = Math.max(0, Math.min(innerHeight - tank.h, tank.y + dy));
}

/* ====== DRAW ====== */
function drawTank(){
  const cx = tank.x + tank.w/2;
  const cy = tank.y + tank.h/2;

  let angle = 0;
  let flipX = 1;

  if (tank.dir === "right") { angle = 0; flipX = 1; }
  if (tank.dir === "left")  { angle = 0; flipX = -1; }   // НЕ переворачиваем вверх ногами
  if (tank.dir === "down")  { angle = Math.PI/2; flipX = 1; }
  if (tank.dir === "up")    { angle = -Math.PI/2; flipX = 1; }

  if (!tankImg._ok){
    drawPlaceholderTank();
    return;
  }

  ctx.save();
  ctx.translate(cx, cy);
  ctx.rotate(angle);
  ctx.scale(flipX, 1);
  ctx.drawImage(tankImg, -tank.w/2, -tank.h/2, tank.w, tank.h);
  ctx.restore();
}

function draw(){
  ctx.clearRect(0,0,innerWidth,innerHeight);

  // фон
  if (bgImg && bgImg._ok) {
    ctx.drawImage(bgImg, 0, 0, innerWidth, innerHeight);
  } else {
    drawDefaultField();
  }

  // ящики
  for(const b of boxes){
    if (boxImg._ok) ctx.drawImage(boxImg, b.x, b.y, b.s, b.s);
    else drawPlaceholderBox(b);
  }

  // танк
  drawTank();
}

/* ====== LOOP ====== */
function loop(){
  update();
  draw();
  requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>
