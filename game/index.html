<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Tank Mission</title>
<style>
  html,body{margin:0;height:100%;background:#05070f;overflow:hidden;}
  canvas{display:block;width:100vw;height:100vh;touch-action:none;}
</style>
</head>
<body>
<canvas id="c"></canvas>

<script>
/* =======================
   1) ЧИТАЕМ НАСТРОЙКИ
   - главный источник: ?config=JSON
   - запасной: отдельные query-поля
   ======================= */
const qs = new URLSearchParams(location.search);

function readConfigJSON() {
  const raw = qs.get("config");
  if (!raw) return {};
  try {
    // editor обычно кладёт уже url-encoded
    const decoded = decodeURIComponent(raw);
    return JSON.parse(decoded);
  } catch (e) {
    try { return JSON.parse(raw); } catch (e2) { return {}; }
  }
}

const cfgFromJSON = readConfigJSON();

function num(v, fallback){ const n = Number(v); return Number.isFinite(n) ? n : fallback; }
function clamp(n, a, b){ return Math.min(b, Math.max(a, n)); }
function pick(key, fallback){
  // приоритет: config JSON -> query -> fallback
  if (cfgFromJSON[key] != null && cfgFromJSON[key] !== "") return cfgFromJSON[key];
  const q = qs.get(key);
  if (q != null && q !== "") return q;
  return fallback;
}

const cfg = {
  tankUrl:   pick("tankUrl", "https://img.genially.com/66f849d0f7b39c0016fdd814/59b10492-4c07-41bd-9331-69042a9d74b9.png"),
  boxUrl:    pick("boxUrl",  "https://img.genially.com/66f849d0f7b39c0016fdd814/9bfc40ad-c0ef-4bb9-a006-30014520bb33.png"),
  bgUrl:     pick("bgUrl",   ""),

  // ВАЖНО: именно эти имена использует редактор: boxCount, speed, tankScale, boxScale
  boxCount:  clamp(num(pick("boxCount", 7), 7), 1, 15),
  speed:     clamp(num(pick("speed", 4), 4), 1, 20),

  tankScale: clamp(num(pick("tankScale", 1), 1), 0.5, 5),
  boxScale:  clamp(num(pick("boxScale", 1), 1), 0.5, 5),
};

/* =======================
   2) CANVAS
   ======================= */
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");

function resize(){
  const dpr = Math.max(1, window.devicePixelRatio || 1);
  canvas.width  = Math.floor(innerWidth * dpr);
  canvas.height = Math.floor(innerHeight * dpr);
  canvas.style.width = innerWidth + "px";
  canvas.style.height = innerHeight + "px";
  ctx.setTransform(dpr,0,0,dpr,0,0);
}
addEventListener("resize", resize);
resize();

/* =======================
   3) IMAGES
   ======================= */
function loadImg(url){
  const img = new Image();
  img.crossOrigin = "anonymous";
  img._ok = false;
  img.onload = ()=> img._ok = true;
  img.onerror = ()=> img._ok = false;
  img.src = url;
  return img;
}
const tankImg = loadImg(cfg.tankUrl);
const boxImg  = loadImg(cfg.boxUrl);
const bgImg   = cfg.bgUrl ? loadImg(cfg.bgUrl) : null;

/* =======================
   4) GAME OBJECTS
   ======================= */
const tankBase = { w: 120, h: 80 };
const boxBase  = { s: 80 };

const tank = {
  x: 0,
  y: 0,
  dir: "right",
  w: tankBase.w * cfg.tankScale,
  h: tankBase.h * cfg.tankScale,
};

function placeTankStart(){
  tank.w = tankBase.w * cfg.tankScale;
  tank.h = tankBase.h * cfg.tankScale;
  tank.x = 40;
  tank.y = innerHeight - tank.h - 40; // нижний левый, не у края
}
placeTankStart();
addEventListener("resize", placeTankStart);

const keys = Object.create(null);
addEventListener("keydown", e => { keys[e.key] = true; });
addEventListener("keyup",   e => { keys[e.key] = false; });

const boxes = [];
function spawnBoxes(){
  boxes.length = 0;
  const size = boxBase.s * cfg.boxScale;

  for(let i=0;i<cfg.boxCount;i++){
    const x = Math.random() * Math.max(1, (innerWidth  - size));
    const y = Math.random() * Math.max(1, (innerHeight - size));
    boxes.push({ x, y, s: size });
  }
}
spawnBoxes();

/* =======================
   5) DRAW HELPERS
   ======================= */
function drawDefaultField(){
  const g = ctx.createRadialGradient(innerWidth*0.5, innerHeight*0.45, 50, innerWidth*0.5, innerHeight*0.5, Math.max(innerWidth, innerHeight));
  g.addColorStop(0, "rgba(20,35,70,1)");
  g.addColorStop(1, "rgba(5,8,16,1)");
  ctx.fillStyle = g;
  ctx.fillRect(0,0,innerWidth,innerHeight);
}

function drawPlaceholderBox(b){
  ctx.save();
  ctx.globalAlpha = 0.85;
  ctx.fillStyle = "rgba(200,200,200,0.25)";
  ctx.strokeStyle = "rgba(255,255,255,0.35)";
  ctx.lineWidth = 2;
  ctx.fillRect(b.x, b.y, b.s, b.s);
  ctx.strokeRect(b.x, b.y, b.s, b.s);
  ctx.restore();
}

function drawPlaceholderTank(){
  ctx.save();
  ctx.globalAlpha = 0.9;
  ctx.fillStyle = "rgba(255,215,0,0.25)";
  ctx.strokeStyle = "rgba(255,215,0,0.5)";
  ctx.lineWidth = 2;
  ctx.fillRect(tank.x, tank.y, tank.w, tank.h);
  ctx.strokeRect(tank.x, tank.y, tank.w, tank.h);
  ctx.restore();
}

/* =======================
   6) UPDATE
   ======================= */
function update(){
  let dx = 0, dy = 0;

  const left  = keys["ArrowLeft"]  || keys["a"] || keys["A"];
  const right = keys["ArrowRight"] || keys["d"] || keys["D"];
  const up    = keys["ArrowUp"]    || keys["w"] || keys["W"];
  const down  = keys["ArrowDown"]  || keys["s"] || keys["S"];

  if (left)  { dx = -cfg.speed; tank.dir = "left"; }
  if (right) { dx =  cfg.speed; tank.dir = "right"; }
  if (up)    { dy = -cfg.speed; tank.dir = "up"; }
  if (down)  { dy =  cfg.speed; tank.dir = "down"; }

  tank.x = Math.max(0, Math.min(innerWidth  - tank.w, tank.x + dx));
  tank.y = Math.max(0, Math.min(innerHeight - tank.h, tank.y + dy));
}

/* =======================
   7) DRAW
   ======================= */
function drawTank(){
  const cx = tank.x + tank.w/2;
  const cy = tank.y + tank.h/2;

  let angle = 0;
  let flipX = 1;

  if (tank.dir === "right") { angle = 0; flipX = 1; }
  if (tank.dir === "left")  { angle = 0; flipX = -1; } // ЛЕВО — только зеркалим по X, не переворачиваем
  if (tank.dir === "down")  { angle = Math.PI/2; flipX = 1; }
  if (tank.dir === "up")    { angle = -Math.PI/2; flipX = 1; }

  if (!tankImg._ok){ drawPlaceholderTank(); return; }

  ctx.save();
  ctx.translate(cx, cy);
  ctx.rotate(angle);
  ctx.scale(flipX, 1);
  ctx.drawImage(tankImg, -tank.w/2, -tank.h/2, tank.w, tank.h);
  ctx.restore();
}

function draw(){
  ctx.clearRect(0,0,innerWidth,innerHeight);

  if (bgImg && bgImg._ok) ctx.drawImage(bgImg, 0, 0, innerWidth, innerHeight);
  else drawDefaultField();

  for(const b of boxes){
    if (boxImg._ok) ctx.drawImage(boxImg, b.x, b.y, b.s, b.s);
    else drawPlaceholderBox(b);
  }

  drawTank();
}

/* =======================
   8) LOOP
   ======================= */
function loop(){
  update();
  draw();
  requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>
